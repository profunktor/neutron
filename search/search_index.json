{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Neutron"},{"location":"/index.html#neutron","text":"Neutron is a purely functional Apache Pulsar client for Scala, build on top of fs2 and the Java client for Pulsar.\nIt is published for Scala 2.13/3.1. You can include it in your project by adding the following dependencies.\nsbt libraryDependencies ++= Seq(\n  \"dev.profunktor\" %% \"neutron-core\" % \"0.3.0\",\n  \"dev.profunktor\" %% \"neutron-circe\" % \"0.3.0\",\n  \"dev.profunktor\" %% \"neutron-function\" % \"0.3.0\"\n) Maven <dependencies>\n  <dependency>\n    <groupId>dev.profunktor</groupId>\n    <artifactId>neutron-core_2.13</artifactId>\n    <version>0.3.0</version>\n  </dependency>\n  <dependency>\n    <groupId>dev.profunktor</groupId>\n    <artifactId>neutron-circe_2.13</artifactId>\n    <version>0.3.0</version>\n  </dependency>\n  <dependency>\n    <groupId>dev.profunktor</groupId>\n    <artifactId>neutron-function_2.13</artifactId>\n    <version>0.3.0</version>\n  </dependency>\n</dependencies> Gradle dependencies {\n  implementation \"dev.profunktor:neutron-core_2.13:0.3.0\"\n  implementation \"dev.profunktor:neutron-circe_2.13:0.3.0\"\n  implementation \"dev.profunktor:neutron-function_2.13:0.3.0\"\n}","title":"Neutron"},{"location":"/index.html#quick-start","text":"Here’s a quick consumer / producer example using neutron. Note: both are fully asynchronous.\nimport scala.concurrent.duration._\n\nimport dev.profunktor.pulsar._\nimport dev.profunktor.pulsar.schema.PulsarSchema\n\nimport cats.effect._\nimport fs2.Stream\n\nobject Demo extends IOApp.Simple {\n\n  val config = Config.Builder.default\n\n  val topic  =\n    Topic.Builder\n      .withName(\"my-topic\")\n      .withConfig(config)\n      .withType(Topic.Type.NonPersistent)\n      .build\n\n  val subs =\n    Subscription.Builder\n      .withName(\"my-sub\")\n      .withType(Subscription.Type.Exclusive)\n      .build\n\n  val schema = PulsarSchema.utf8\n\n  val resources: Resource[IO, (Consumer[IO, String], Producer[IO, String])] =\n    for {\n      pulsar   <- Pulsar.make[IO](config.url)\n      consumer <- Consumer.make[IO, String](pulsar, topic, subs, schema)\n      producer <- Producer.make[IO, String](pulsar, topic, schema)\n    } yield consumer -> producer\n\n  val run: IO[Unit] =\n    Stream\n      .resource(resources)\n      .flatMap {\n        case (consumer, producer) =>\n          val consume =\n            consumer\n              .autoSubscribe\n              .evalMap(IO.println)\n\n          val produce =\n            Stream\n              .emit(\"test data\")\n              .covary[IO]\n              .metered(3.seconds)\n              .evalMap(producer.send_)\n\n          consume.concurrently(produce)\n      }\n      .compile\n      .drain\n\n}","title":"Quick start"},{"location":"/reference/Index.html","text":"","title":"Reference"},{"location":"/reference/Index.html#reference","text":"This section contains detailed discussions of Neutron’s core abstractions and machinery.","title":"Reference"},{"location":"/reference/Index.html#table-of-contents","text":"Connection Configuration Pulsar client Consumer Subscriptions Creating a Consumer Auto-subscription Manual ack Manual subscription Unsubscribe Consumer settings Producer Creating a Producer Publishing a message Deduplication Producer settings Reader Creating a Reader Reading messages Reader settings Schema UTF-8 JSON support Schema Compatibility Check Strategy Topic Single Multiple Transactions Working with transactions Summary","title":"Table of Contents"},{"location":"/reference/Connection.html","text":"","title":"Connection"},{"location":"/reference/Connection.html#connection","text":"A connection to Apache Pulsar is an expensive operation, reason why it is recommended to create a single instance per application.\nThe main constructor returns a cats.effect.Resource, and is defined as follows.\nimport cats.effect._\nimport dev.profunktor.pulsar.Config.PulsarURL\nimport dev.profunktor.pulsar.Pulsar.Settings\n\nimport org.apache.pulsar.client.api.{ PulsarClient => Underlying }\n\ntype T = Underlying\n\ndef make[F[_]: Sync](\n    url: PulsarURL,\n    settings: Settings = Settings()\n): Resource[F, T] = ???\nA PulsarURL can only be built using smart builders, as shown in the next section.","title":"Connection"},{"location":"/reference/Connection.html#configuration","text":"A default configuration is usually enough to get started locally.\nimport dev.profunktor.pulsar.Config\n\nval config = Config.Builder.default\nIt sets tenant=public, namespace=default, and url=pulsar://localhost:6650. If would like to change any of these values, you can use the configuration builder. E.g.\nval custom: Config =\n  Config.Builder\n    .withTenant(\"custom\")\n    .withNameSpace(\"services\")\n    .withURL(\"pulsar://custom.net:6650\")\n    .build","title":"Configuration"},{"location":"/reference/Connection.html#pulsar-client","text":"Once we have a configuration, we can proceed with the creation of a Pulsar client, necessary to create consumers, producers, and so on.\nimport dev.profunktor.pulsar._\n\nPulsar.make[IO](config.url)","title":"Pulsar client"},{"location":"/reference/Connection.html#connection-settings","text":"Via the second constructor argument, we can set a few client options, such as timeouts.\nimport scala.concurrent.duration._\n\nval settings =\n  Settings()\n    .withConnectionTimeout(45.seconds)\n    .withOperationTimeout(30.minutes)\n    .withTransactions\n\nPulsar.make[IO](config.url, settings)\nTo learn more about transactions, check out the Transactions section.","title":"Connection settings"},{"location":"/reference/Consumer.html","text":"","title":"Consumer"},{"location":"/reference/Consumer.html#consumer","text":"A consumer is a process that attaches to a topic via a subscription, in order to receive messages.\nNeutron models it via a tagless algebra.\nimport dev.profunktor.pulsar._\n\nimport fs2.Stream\nimport org.apache.pulsar.client.api.MessageId\n\nobject Consumer {\n  case class Message[A](\n      id: MessageId,\n      key: MessageKey,\n      properties: Map[String, String],\n      payload: A\n  )\n}\n\ntrait Consumer[F[_], E] {\n  def ack(id: MessageId): F[Unit]\n  def nack(id: MessageId): F[Unit]\n  def subscribe: Stream[F, Consumer.Message[E]]\n  def subscribe(id: MessageId): Stream[F, Consumer.Message[E]]\n  def autoSubscribe: Stream[F, E]\n  def unsubscribe: F[Unit]\n}\nWe will expand on its methods in the next few sections.","title":"Consumer"},{"location":"/reference/Consumer.html#subscriptions","text":"Pulsar supports multiple subscription modes, which can be created in Neutron via smart builders.\nimport dev.profunktor.pulsar._\n\nval subs =\n  Subscription.Builder\n    .withName(\"my-sub\")\n    .withType(Subscription.Type.Shared)\n    .build\nThere are four types of subscriptions: Exclusive, Shared, KeyShared, and Failover.","title":"Subscriptions"},{"location":"/reference/Consumer.html#creating-a-consumer","text":"There are a few smart constructors we can use to create a consumer. If we want Pulsar schema support, we have the following one (also another one that takes an extra argument for the consumer settings).\nimport org.apache.pulsar.client.api.Schema\n\ndef make[F[_]: FutureLift: Sync, E](\n    client: Pulsar.T,\n    topic: Topic,\n    sub: Subscription,\n    schema: Schema[E]\n): Resource[F, Consumer[F, E]] = ???\nIf we do not want Pulsar schema support, then we need to provide a message decoder, and ideally a decoding error handler, which are both functions.\ndef make[F[_]: FutureLift: Sync, E](\n    client: Pulsar.T,\n    topic: Topic,\n    sub: Subscription,\n    messageDecoder: Array[Byte] => F[E],\n    decodingErrorHandler: Throwable => F[OnFailure] // defaults to Raise\n): Resource[F, Consumer[F, E]] = ???\nFor example, an UTF-8 encoded string could be the following one:\nimport java.nio.charset.StandardCharsets.UTF_8\n\nval utf8Decoder: Array[Byte] => IO[String] =\n  bs => IO(new String(bs, UTF_8))\nOr we could use a JSON decoder powered by Circe:\nimport io.circe.Decoder\n\ndef jsonDecoder[A: Decoder]: Array[Byte] => IO[A] =\n  bs => IO.fromEither(io.circe.parser.decode[A](new String(bs, UTF_8)))\nIf we do not specify the decoding error handler, then the default is to re-raise the error when a message cannot be decoded. That’s usually a sane default, but every case is different and you might want to ack or nack the message, which can be done as follows:\nval handler: Throwable => IO[Consumer.OnFailure] =\n  e => IO.println(s\"[error] - ${e.getMessage}\").as(Consumer.OnFailure.Nack)\nThere are many smart constructors to ensure you create a consumer with a valid state. Check out all of them in the API or source code.\nOnce we have a subscription, we can create a consumer, assuming we also have a pulsar connection and a topic.\nIf you missed that part, check out the connection and topic docs.\nimport dev.profunktor.pulsar.schema.PulsarSchema\n\nimport cats.effect._\n\nval schema = PulsarSchema.utf8\n\ndef creation(\n    pulsar: Pulsar.T,\n    topic: Topic\n): Resource[IO, Consumer[IO, String]] =\n  Consumer.make[IO, String](pulsar, topic, subs, schema)","title":"Creating a Consumer"},{"location":"/reference/Consumer.html#auto-subscription","text":"This is the easiest way to get started with a consumer. Once a message is received, it will be automatically acknowledged (ack) by us. It is done via the autoSubscribe method, as shown below.\ndef auto(\n    consumer: Consumer[IO, String]\n): IO[Unit] =\n  consumer\n   .autoSubscribe\n   .evalMap(IO.println)\n   .compile\n   .drain\nIn this case, autoSubscribe returns Stream[IO, String], meaning we directly get the body of the message.","title":"Auto-subscription"},{"location":"/reference/Consumer.html#manual-ack","text":"In most serious applications, this should be the preferred way to consume messages, to avoid losing messages whenever the application fails after consuming a message.\nFor this purpose, we can use the subscribe method, as shown in the example below.\ndef process(payload: String): IO[Unit] =\n  IO.println(s\"Payload: $payload\")\n\ndef manual(\n    consumer: Consumer[IO, String]\n): IO[Unit] =\n  consumer\n   .subscribe\n   .evalMap { case Consumer.Message(id, _, _, payload) =>\n     process(payload) // pretend `process` might raise an error\n       .flatMap(_ => consumer.ack(id))\n       .handleErrorWith(e => IO.println(e) *> consumer.nack(id))\n   }\n   .compile\n   .drain\nIt allows us to decide whether to ack or nack a message (it will be re-delivered by Pulsar).","title":"Manual ack"},{"location":"/reference/Consumer.html#manual-subscription","text":"As shown in the section above, we can use the subscribe method to manually handle acknowledgements. Additionally, we have another variant of subscribe that takes a MessageId as an argument.\ndef subscribe(id: MessageId): Stream[F, Consumer.Message[E]]\nThis type of subscription will override the SubscriptionInitialPosition set in the settings and point this consumer to a specific message id — internally done via seekAsync. This could be useful when we know exactly how far we want to rewind or where exactly we would like to start consuming.","title":"Manual subscription"},{"location":"/reference/Consumer.html#unsubscribe","text":"We can unsubscribe from a topic via the unsubscribe method, which implies deleting the subscription. We can do this whenever we are sure the process is over and we no longer need such subscription.\ndef finish(\n    consumer: Consumer[IO, String]\n): IO[Unit] =\n  consumer\n   .autoSubscribe\n   .evalMap(IO.println)\n   .onFinalize(consumer.unsubscribe)\n   .compile\n   .drain\nThis functionality can be enabled to be performed automatically via the autoUnsubscribe option.","title":"Unsubscribe"},{"location":"/reference/Consumer.html#consumer-settings","text":"When creating a consumer, we can choose to customize the default options. E.g.\nimport java.nio.charset.StandardCharsets.UTF_8\n\nimport org.apache.pulsar.client.api.{\n  DeadLetterPolicy,\n  SubscriptionInitialPosition\n}\n\nval deadLetterPolicy =\n  DeadLetterPolicy\n    .builder()\n    .deadLetterTopic(\"foo\")\n    .maxRedeliverCount(100)\n    .retryLetterTopic(\"bar\")\n    .build()\n\nval utf8Decoder: Array[Byte] => IO[String] =\n  bs => IO(new String(bs, UTF_8))\n\nval handler: Throwable => IO[Consumer.OnFailure] =\n  e => IO.println(s\"[error] - ${e.getMessage}\").as(Consumer.OnFailure.Nack)\n\nval settings =\n  Consumer.Settings[IO, String]()\n   .withInitialPosition(SubscriptionInitialPosition.Earliest)\n   .withLogger(e => url => IO.println(s\"Message: $e, URL: $url\"))\n   .withAutoUnsubscribe\n   .withReadCompacted\n   .withDeadLetterPolicy(deadLetterPolicy)\n   .withUnsafeConf(_.autoUpdatePartitions(false))\n\ndef custom(\n    pulsar: Pulsar.T,\n    topic: Topic\n): Resource[IO, Consumer[IO, String]] =\n  Consumer.make[IO, String](\n    pulsar,\n    topic,\n    subs,\n    utf8Decoder,\n    handler,\n    settings\n  )","title":"Consumer settings"},{"location":"/reference/Producer.html","text":"","title":"Producer"},{"location":"/reference/Producer.html#producer","text":"A producer is a process that attaches to a topic and publishes messages to a Pulsar broker.\nNeutron models it via a tagless algebra.\nimport org.apache.pulsar.client.api.{ MessageId, ProducerStats }\n\ntrait Producer[F[_], E] {\n  def send(msg: E): F[MessageId]\n  def send(msg: E, properties: Map[String, String]): F[MessageId]\n  def stats: F[ProducerStats]\n}\nAs well as the send_ equivalent that discards the MessageId and returns F[Unit]. We will expand on its methods in the next few sections.","title":"Producer"},{"location":"/reference/Producer.html#creating-a-producer","text":"It defines a few constructs, similarly as Consumer does. If we need Pulsar schema support, this is the constructor (also another one that takes in an extra argument for the producer settings):\ndef make[F[_]: FutureLift: Parallel: Sync, E](\n    client: Pulsar.T,\n    topic: Topic.Single,\n    schema: Schema[E]\n): Resource[F, Producer[F, E]] = ???\nIf we do not need Pulsar schema support, we need to provide a message encoder.\ndef make[F[_]: FutureLift: Parallel: Sync, E](\n    client: Pulsar.T,\n    topic: Topic.Single,\n    messageEncoder: E => Array[Byte]\n): Resource[F, Producer[F, E]] = ???\nCheck out all the available smart constructors either in the API or in the source code.\nOnce we have a connection and a topic, we can proceed with the creation of producer. If you missed that part, check out the connection and topic docs.\nimport dev.profunktor.pulsar._\nimport dev.profunktor.pulsar.schema.PulsarSchema\n\nimport cats.effect._\n\nval schema = PulsarSchema.utf8\n\ndef creation(\n    pulsar: Pulsar.T,\n    topic: Topic.Single\n): Resource[IO, Producer[IO, String]] =\n  Producer.make[IO, String](pulsar, topic, schema)","title":"Creating a Producer"},{"location":"/reference/Producer.html#publishing-a-message","text":"We can publish a message via the send method, which returns a MessageId we could potentially use to store in the application’s state. If you don’t need it, prefer to use send_ instead.\ndef simple(\n    producer: Producer[IO, String]\n): IO[Unit] =\n  producer.send_(\"some-message\")","title":"Publishing a message"},{"location":"/reference/Producer.html#deduplication","text":"Pulsar supports deduplication at the broker level.\nIn a nutshell, the deduplication mechanism is based on sequence ids, which can be set on every message on the underlying Java client.\nTo make things smoother, Neutron internally manages the creation of new sequence ids via the following interface.\ntrait SeqIdMaker[A] {\n  def next(prevId: Long, prevPayload: Option[A], payload: A): Long\n}\nA default instance for any A: Eq can be constructed via the fromEq method, which compares the previous payload with the current payload. If they are equal, the same sequence id is returned. Otherwise, a prevId + 1 is used.\nval seqIdMaker = SeqIdMaker.fromEq[String]\nThis instance is usually good enough, as Pulsar only requires the next sequence id should be greater than the previous one. However, if for some reason you need a different implementation, you can write your own instance.\nTo enable deduplication, we can use the following setting.\nProducer.Settings[IO, String]().withDeduplication(seqIdMaker)\nThe DeduplicationSuite showcases this feature (also see the run.sh script, where deduplication is enabled at the topic level).","title":"Deduplication"},{"location":"/reference/Producer.html#producer-settings","text":"The producer constructor can also be customized with a few extra options. E.g.\nimport java.nio.charset.StandardCharsets.UTF_8\n\nimport scala.concurrent.duration._\n\nval batching =\n  Producer.Batching.Enabled(maxDelay = 5.seconds, maxMessages = 500)\n\nval encoder: String => Array[Byte] =\n _.getBytes(UTF_8)\n\nval settings =\n  Producer.Settings[IO, String]()\n   .withBatching(batching)\n   .withMessageKey(s => MessageKey.Of(s.hashCode.toString))\n   .withShardKey(s => ShardKey.Of(s.hashCode.toString.getBytes))\n   .withLogger(e => url => IO.println(s\"Message: $e, URL: $url\"))\n   .withUnsafeConf(_.autoUpdatePartitions(false))\n\ndef custom(\n    pulsar: Pulsar.T,\n    topic: Topic.Single\n): Resource[IO, Producer[IO, String]] =\n  Producer.make(pulsar, topic, encoder, settings)\nThe withShardKey option is quite useful when we want to publish messages based on certain property of your messages, e.g. an EventId. This applies when you use it together with KeyShared subscriptions, on the consumer side. Internally, this sets the orderingKey of every message.\nOn the other hand, the withMessageKey option sets the “partitioning key” of every message, used for compacted topics. Also bear in mind that if you use a KeyShared subscription but don’t set the orderingKey (via withShardKey), the default MessageKey will be used.","title":"Producer settings"},{"location":"/reference/Reader.html","text":"","title":"Reader"},{"location":"/reference/Reader.html#reader","text":"A reader allows you to “manually position” the offset within a topic and reading all messages from a specified message onward. For instance, you can start from a specific MessageId.\nNeutron models it via a tagless algebra, as usual.\nimport scala.concurrent.duration.FiniteDuration\nimport fs2.Stream\n\nobject Reader {\n  sealed trait MessageAvailable\n  object MessageAvailable {\n    case object Yes extends MessageAvailable\n    case object No extends MessageAvailable\n  }\n}\n\ntrait Reader[F[_], E] {\n  def read: Stream[F, E]\n  def read1: F[Option[E]]\n  def readUntil(timeout: FiniteDuration): F[Option[E]]\n  def messageAvailable: F[Reader.MessageAvailable]\n}\nThere’s also a MessageReader algebra, useful whenever you need more than the payload of the message, such as the MessageId and MessageKey.","title":"Reader"},{"location":"/reference/Reader.html#creating-a-reader","text":"It provides a few constructors as both Consumer and Producer do for schema and message decoders. E.g.\nimport dev.profunktor.pulsar._\nimport dev.profunktor.pulsar.Reader.Settings\nimport org.apache.pulsar.client.api.Schema\n\nimport cats.effect._\n\ndef make[F[_]: Sync, E](\n    client: Pulsar.T,\n    topic: Topic.Single,\n    schema: Schema[E],\n    settings: Settings[F, E]\n): Resource[F, Reader[F, E]] = ???\nIf you’re interested in a MessageReader instead, you can use messageReader instead of make. Check out all the available smart constructors either in the API or source code.\nOnce we have a Pulsar client and a topic, we can proceed with the creation of a reader. If you missed that part, check out the connection and topic docs.\nimport dev.profunktor.pulsar._\nimport dev.profunktor.pulsar.schema.PulsarSchema\n\nimport cats.effect._\n\nval schema = PulsarSchema.utf8\n\ndef creation(\n    pulsar: Pulsar.T,\n    topic: Topic.Single\n): Resource[IO, Reader[IO, String]] =\n  Reader.make[IO, String](pulsar, topic, schema)","title":"Creating a Reader"},{"location":"/reference/Reader.html#reading-messages","text":"We can use any of the available read methods. E.g.\ndef simple(\n    reader: Reader[IO, String]\n): IO[Unit] =\n  reader\n   .read\n   .evalMap(IO.println)\n   .compile\n   .drain\nOr we can first ask whether there are available messages or not via messageAvailable.","title":"Reading messages"},{"location":"/reference/Reader.html#reader-settings","text":"The reader constructor can also be customized with a few extra options. E.g.\nimport org.apache.pulsar.client.api.MessageId\n\nval msgId: MessageId = null\n\nval settings =\n  Reader.Settings[IO, String]()\n   .withStartMessageId(msgId)\n   .withReadCompacted\n\ndef custom(\n    pulsar: Pulsar.T,\n    topic: Topic.Single\n): Resource[IO, Reader[IO, String]] =\n  Reader.make(pulsar, topic, schema, settings)\nIt is the responsibility of the application to know the specific MessageId, which internally represents a Ledger ID, Entry ID, and Partition ID.","title":"Reader settings"},{"location":"/reference/Schema.html","text":"","title":"Schema"},{"location":"/reference/Schema.html#schema","text":"Neutron ships with support for Pulsar schemas, which are validated by Pulsar at the topic level, via an internal schema registry.\nThere are pros and cons to using the native support, so make sure you give the official documentation a thorough read before making a decision.\nIf you only want to play around with Pulsar to get familiar with it, you can either choose UTF-8 or the simple JSON support via SchemaType.BYTES, which have no validation whatsoever, as explained in the next sections.","title":"Schema"},{"location":"/reference/Schema.html#utf-8","text":"The simplest way to get started is to use the given UTF-8 encoding, which makes use of the native Schema.BYTES.\nimport dev.profunktor.pulsar.schema.PulsarSchema\nimport org.apache.pulsar.client.api.Schema\n\nval schema: Schema[String] = PulsarSchema.utf8\nHere we create a Schema[String], required to initialize consumers and producers with Pulsar schema support.\nNote When using schemas, prefer to create the producer(s) before the consumer(s) for fail-fast semantics.","title":"UTF-8"},{"location":"/reference/Schema.html#json-support","text":"One of the most common communication protocols is JSON, and Neutron integrates with the Circe library to support it via the neutron-circe dependency.\nIt sets SchemaType.JSON, which means topics can be inspected by Pulsar Functions and so on, and it is validated by Pulsar at runtime, when creating producers and consumers.\nThe recommended one is based on semi-automatic derivation, as shown in the example below.\nimport dev.profunktor.pulsar.schema.circe.JsonSchema\nimport org.apache.pulsar.client.api.Schema\n\nimport io.circe.{Decoder, Encoder}\nimport io.circe.generic.semiauto._\n\ncase class Event(id: Long, name: String)\nobject Event {\n  implicit val jsonEncoder: Encoder[Event] = deriveEncoder\n  implicit val jsonDecoder: Decoder[Event] = deriveDecoder\n}\n\nval schema: Schema[Event] = JsonSchema.make[Event]\nIt requires instances of Decoder and Encoder, and of SchemaFor, which comes from the avro4s library.\nNotice that avro4s is marked as Provided, meaning you need to explicitly add it to your classpath.","title":"JSON support"},{"location":"/reference/Schema.html#schema-compatibility-check-strategy","text":"Whenever using schemas, make sure you fully understand the different strategies, which only operate at the namespace level (e.g. see how integration tests are set up in the run.sh shell script).\nFor instance, when using the BACKWARD mode, a producer and consumer will fail to initialize if the schemas are incompatible, even if your custom JSON decoder can deserialize the previous model, the Pulsar broker doesn’t know about it. E.g. say we have this model in our new application.\ncase class Event(uuid: UUID, value: String)\nThe generated Avro schema will look as follows.\n{\n  \"type\" : \"record\",\n  \"name\" : \"Event\",\n  \"namespace\" : \"dev.profunktor.pulsar.domain\",\n  \"fields\" : [ {\n    \"name\" : \"uuid\",\n    \"type\" : {\n      \"type\" : \"string\",\n      \"logicalType\" : \"uuid\"\n    }\n  }, {\n    \"name\" : \"value\",\n    \"type\" : \"string\"\n  } ]\n}\nAnd later on, we introduce a breaking change in the model, adding a new mandatory field.\ncase class Event(uuid: UUID, value: String, code: Int)\nThis will be rejected at runtime, validated by Pulsar Schemas, when using the BACKWARD mode. The only changes allowed in this mode are:\nAdd optional fields Delete fields\nSee the generated Avro schema below.\n{\n  \"type\" : \"record\",\n  \"name\" : \"Event\",\n  \"namespace\" : \"dev.profunktor.pulsar.domain\",\n  \"fields\" : [ {\n    \"name\" : \"uuid\",\n    \"type\" : {\n      \"type\" : \"string\",\n      \"logicalType\" : \"uuid\"\n    }\n  }, {\n    \"name\" : \"value\",\n    \"type\" : \"string\"\n  }, {\n    \"name\" : \"code\",\n    \"type\" : \"int\"\n  } ]\n}\nInstead, we should make the new field optional with a default value for this to work.\ncase class Event(uuid: UUID, value: String, code: Option[Int] = None)\nThis is now accepted by Pulsar since any previous Event still not consumed from a Pulsar topic can still be processed by the new consumers expecting the new schema.\n{\n  \"type\" : \"record\",\n  \"name\" : \"Event\",\n  \"namespace\" : \"dev.profunktor.pulsar.domain\",\n  \"fields\" : [ {\n    \"name\" : \"uuid\",\n    \"type\" : {\n      \"type\" : \"string\",\n      \"logicalType\" : \"uuid\"\n    }\n  }, {\n    \"name\" : \"value\",\n    \"type\" : \"string\"\n  }, {\n    \"name\" : \"code\",\n    \"type\" : [ \"null\", \"int\" ],\n    \"default\" : null\n  } ]\n}\nSee the difference with the previous schema? This one has a default: null in addition to the extra null type.","title":"Schema Compatibility Check Strategy"},{"location":"/reference/Topic.html","text":"","title":"Topic"},{"location":"/reference/Topic.html#topic","text":"A Topic has a well-defined structure.\n{persistent|non-persistent}://tenant/namespace/topic\nTo ensure correctness, it is necessary to build topics via smart builders.","title":"Topic"},{"location":"/reference/Topic.html#single","text":"A single topic is built via a Topic.Builder, as we have seen in the quick start section.\nimport dev.profunktor.pulsar._\n\nval config = Config.Builder.default\n\nval single: Topic.Single =\n  Topic.Builder\n    .withName(\"my-topic\")\n    .withConfig(config)\n    .withType(Topic.Type.Persistent)\n    .build\nTo learn more about configurations, check out the Connection section.","title":"Single"},{"location":"/reference/Topic.html#multiple","text":"Pulsar also supports subscriptions to multiple topics, which can be built using the same smart builder.\nval multi: Topic.Multi =\n  Topic.Builder\n    .withNamePattern(\"events-*\".r)\n    .withConfig(config)\n    .withType(Topic.Type.Persistent)\n    .buildMulti\nThe withNamePattern method takes a regular expression as input.","title":"Multiple"},{"location":"/reference/Transactions.html","text":"","title":"Transactions"},{"location":"/reference/Transactions.html#transactions","text":"Pulsar supports transactions to further enable event streaming applications to consume, process, and produce messages in one atomic operation.\nNotice that the broker needs to be configured to support transactions (disabled by default).\ntransactionCoordinatorEnabled=true\nNaturally, Neutron models a transaction as Resource[F, Tx], where Tx is a custom interface that hides the underlying Java Transaction instance to avoid user mistakes.\nsealed trait Tx {\n  def getId: TxnID\n}","title":"Transactions"},{"location":"/reference/Transactions.html#working-with-transactions","text":"The first step is to enable transactions on the Pulsar client.\nimport cats.effect._\nimport dev.profunktor.pulsar._\n\nval cfg = Config.Builder.default\n\nval mkClient =\n  Pulsar.make[IO](cfg.url, Pulsar.Settings().withTransactions)\nNext, we can create a transactional resource.\nimport scala.concurrent.duration._\nimport dev.profunktor.pulsar.transactions.{ PulsarTx, Tx }\n\nmkClient.use { cli =>\n  val mkTx = PulsarTx.make[IO](\n    client = cli,\n    timeout = 30.seconds,\n    logger = str => IO.println(str)\n  )\n\n  mkTx.use { tx =>\n    // atomic transactions here\n    IO.println(s\"tx-id: ${tx.getId}\")\n  }\n}\nNow we are ready to use the transaction for some atomic operations. Once we use the resource, the transaction will begin. From this point, we can consume, process, and produce messages in a transactional fashion.\nThe TransactionSuite showcases this feature in detail.\nIn a nutshell, we have two producers and two consumers in total, for inputs and outputs, respectively.\nThe first producer pi produces inputs that the ci consumer reads. These inputs are processed and the results are published as outputs by the po producer. Lastly, the co consumer would read these outputs.\nThe atomic operations happen between reading inputs and publishing outputs. To do so, the ci consumer keeps track of the MessageIds in memory, to then acknowledge them once we are done with the transaction.\nval consumeInputs =\n  ci.subscribe.evalMap {\n    case Consumer.Message(id, _, _, payload) =>\n      for {\n        _ <- ref.update(_ :+ payload)\n        _ <- ids.update(_ + id)\n        _ <- po.send_(s\"$payload-out\")\n      } yield ()\n  }\nWe accumulate MessageIds in a local ids ref. Here’s the inputs producer:\nval produceInputs =\n  Stream.emits(events).evalMap(pi.send_) ++ Stream.eval {\n    latch.get *> ids.get.flatMap(_.toList.traverse_(ci.ack(_, tx)))\n  }\nOnce the producer finishes, it proceeds to atomically acknowledge the MessageIds we have in memory. To do so, we use the special ack method that also takes a Tx as argument.\nThat latch.get is only there to synchronize the order in which things terminate in the test suite. Your use case may be handled differently.\nWhen the resource scope ends, the transaction will be committed. If we wanted to abort the transaction instead, all we need is to raise an error. E.g.\nlatch.get *> IO.raiseError(new Exception(\"Abort tx\"))\nThis error should be handled outside the resource scope to avoid crashing the entire program.","title":"Working with transactions"},{"location":"/reference/Transactions.html#summary","text":"In short, it all boils down to the following operations.\nEnable transactions support on the broker (via broker.conf or standalone.conf). Enable transactions support on the client (via withTransactions on settings). Acknowledge messages via ack(id, tx) after the processing and publishing of messages is done, to guarantee one atomic operation. Raise an error within the use block of the transaction to abort. Exit the use block to commit the transaction (done automatically).","title":"Summary"}]}